/**
 * @file GraphBuilder.h
 * @brief Header file for the GraphBuilder class, responsible for constructing the network traffic graph.
 *
 * This file defines the `GraphBuilder` class,
 * which form the data structures and logic for building a graph
 * of network traffic based on Zeek logs.
 */

// Created by lu on 4/25/25.
//

#ifndef GRAPHBUILDER_H
#define GRAPHBUILDER_H
//
// Created by lu on 4/25/25.
//  --> Redundant include

#include <memory>
#include <mutex>
#include <vector>
#include <unordered_map> // Include for std::unordered_map
#include <string> // Include for std::string
#include <tuple> // Include for std::tuple
#include <functional> // For std::hash and std::equal_to

#include "EdgeFeatureEncoder.h"
#include "NodeFeatureEncoder.h"
#include "TrafficGraph.h"
#include "AggregatedGraphEdge.h" // Include for AggregatedGraphEdge


namespace std {
template <>
struct hash<std::tuple<std::string, std::string, std::string, std::string, std::string>> {
    size_t operator()(const std::tuple<std::string, std::string, std::string, std::string, std::string>& t) const {
        size_t h1 = std::hash<std::string>{}(std::get<0>(t));
        size_t h2 = std::hash<std::string>{}(std::get<1>(t));
        size_t h3 = std::hash<std::string>{}(std::get<2>(t));
        size_t h4 = std::hash<std::string>{}(std::get<3>(t));
        size_t h5 = std::hash<std::string>{}(std::get<4>(t));
        return h1 ^ (h2 << 1) ^ (h3 >> 1) ^ (h4 << 2) ^ (h5 >> 2);
    }
};
} // namespace std


/**
 * @brief Singleton class responsible for building and managing the network traffic graph.
 *
 * The `GraphBuilder` class provides a single point of access to the `TrafficGraph`
 * and offers methods to process raw network traffic data (e.g., from Zeek logs)
 * and add corresponding nodes and aggregated edges to the graph. The singleton pattern ensures
 * that only one instance of the graph builder exists throughout the application.
 */
class GraphBuilder {
private:
    /**
     * @brief Static unique pointer to the single instance of GraphBuilder.
     */
    static std::unique_ptr<GraphBuilder> instance;
    /**
     * @brief Static mutex to protect the creation of the singleton instance in a thread-safe manner.
     */
    static std::mutex instance_mutex;

    /**
     * @brief The underlying traffic graph being built and managed.
     */
    TrafficGraph graph;

    /**
     * @brief Map to store aggregated edges, keyed by (src_ip, dst_ip, protocol, service, dst_port).
     */
    std::unordered_map<std::tuple<std::string, std::string, std::string, std::string, std::string>, AggregatedGraphEdge> aggregated_edges;

    /**
     * @brief Default Constructor. Private to enforce signeton pattern.
     */
    GraphBuilder() = default;

    /**
     * @brief Feature encoder. Useful for passing data to GAT.
     */
    EdgeFeatureEncoder edge_encoder;
    NodeFeatureEncoder node_encoder;
    std::atomic<bool> save_pending{false};

public:
    /**
     * @brief Deleted copy constructor to prevent copying of the singleton instance.
     */
    GraphBuilder(const GraphBuilder &) = delete;

    /**
     * @brief Deleted assignment operator to prevent assignment of the singleton instance.
     * @return void
     */
    GraphBuilder &operator=(const GraphBuilder &) = delete;

    /**
     * @brief Gets the singleton instance of the GraphBuilder.
     *
     * This is the entry point to access the GraphBuilder. If the instance has not
     * been created yet, it creates one in a thread-safe way.
     *
     * @return A reference to the single GraphBuilder instance.
     */
    static GraphBuilder &get_instance() {
        std::lock_guard lock(instance_mutex);
        if (!instance) {
            instance = std::unique_ptr<GraphBuilder>(new GraphBuilder());
        }
        return *instance;
    }


    /**
     * @brief Processes a network connection event and adds the corresponding nodes and aggregated edge to the graph.
     *
     * This method takes the raw connection attributes (as a feature map) and the already encoded
     * feature vector for the connection. It updates the traffic graph by adding or retrieving
     * the involved nodes and creating or updating an aggregated edge representing the connection type
     * between them. It also updates the temporal features of the nodes.
     *
     * @param raw_feature_map A map containing the raw string attributes of the network connection.
     * This is used to extract specific raw values like src_ip, dst_ip, protocol,
     * service, and dst_port needed for graph structure and edge aggregation.
     * @param encoded_features A vector of floats representing the already encoded numerical features
     * of this connection, generated by the FeatureEncoder. This vector will
     * be aggregated into the corresponding edge.
     */
    void add_connection(const std::unordered_map<std::string, std::string> &raw_feature_map,
                        std::vector<float> &encoded_features);

    /**
     * @brief Gets a reference to the underlying TrafficGraph object.
     *
     * This method provides access to the `TrafficGraph` object managed by the `GraphBuilder`.
     *
     * @return A reference to the TrafficGraph object.
     */
    TrafficGraph &get_graph();

    /**
     * @brief Gets the dimension of the encoded feature vector
     * @return Size of feature vector produced by the encoder
     */
    size_t get_feature_dimension() const {
        // This should match your encoder's output size
        return edge_encoder.get_feature_dimension();
    }
};


#endif //GRAPHBUILDER_H